/**
 * Code generated by Microsoft (R) AutoRest Code Generator 1.1.0.0
 * Changes may cause incorrect behavior and will be lost if the code is
 * regenerated.
 */

package com.microsoft.healthvault.restapi.implementation;

import retrofit2.Retrofit;
import com.microsoft.healthvault.restapi.ActionPlans;
import com.google.common.reflect.TypeToken;
import com.microsoft.healthvault.restapi.models.ActionPlan;
import com.microsoft.healthvault.restapi.models.ActionPlanAdherenceSummary;
import com.microsoft.healthvault.restapi.models.ActionPlanInstance;
import com.microsoft.healthvault.restapi.models.ActionPlansResponseActionPlanInstance;
import com.microsoft.healthvault.restapi.models.ErrorResponseException;
import com.microsoft.rest.ServiceCallback;
import com.microsoft.rest.ServiceFuture;
import com.microsoft.rest.ServiceResponse;
import com.microsoft.rest.Validator;
import java.io.IOException;
import java.util.UUID;
import okhttp3.ResponseBody;
import org.joda.time.DateTime;
import retrofit2.http.Body;
import retrofit2.http.GET;
import retrofit2.http.Headers;
import retrofit2.http.HTTP;
import retrofit2.http.PATCH;
import retrofit2.http.Path;
import retrofit2.http.POST;
import retrofit2.http.PUT;
import retrofit2.http.Query;
import retrofit2.Response;
import rx.functions.Func1;
import rx.Observable;

/**
 * An instance of this class provides access to all the operations defined
 * in ActionPlans.
 */
public class ActionPlansImpl implements ActionPlans {
    /** The Retrofit service to perform REST calls. */
    private ActionPlansService service;
    /** The service client containing this operation class. */
    private MicrosoftHealthVaultRESTAPIImpl client;

    /**
     * Initializes an instance of ActionPlans.
     *
     * @param retrofit the Retrofit instance built from a Retrofit Builder.
     * @param client the instance of the service client containing this operation class.
     */
    public ActionPlansImpl(Retrofit retrofit, MicrosoftHealthVaultRESTAPIImpl client) {
        this.service = retrofit.create(ActionPlansService.class);
        this.client = client;
    }

    /**
     * The interface defining all the services for ActionPlans to be
     * used by Retrofit to perform actually REST calls.
     */
    interface ActionPlansService {
        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.healthvault.restapi.ActionPlans getById" })
        @GET("ActionPlans/{actionPlanId}")
        Observable<Response<ResponseBody>> getById(@Path("actionPlanId") UUID actionPlanId);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.healthvault.restapi.ActionPlans delete" })
        @HTTP(path = "ActionPlans/{actionPlanId}", method = "DELETE", hasBody = true)
        Observable<Response<ResponseBody>> delete(@Path("actionPlanId") UUID actionPlanId);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.healthvault.restapi.ActionPlans get" })
        @GET("ActionPlans")
        Observable<Response<ResponseBody>> get(@Query("maxPageSize") Integer maxPageSize);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.healthvault.restapi.ActionPlans replace" })
        @PUT("ActionPlans")
        Observable<Response<ResponseBody>> replace(@Body ActionPlanInstance actionPlan);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.healthvault.restapi.ActionPlans create" })
        @POST("ActionPlans")
        Observable<Response<ResponseBody>> create(@Body ActionPlan actionPlan);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.healthvault.restapi.ActionPlans update" })
        @PATCH("ActionPlans")
        Observable<Response<ResponseBody>> update(@Body ActionPlanInstance actionPlan);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.healthvault.restapi.ActionPlans getAdherence" })
        @GET("ActionPlans/{actionPlanId}/Adherence")
        Observable<Response<ResponseBody>> getAdherence(@Path("actionPlanId") UUID actionPlanId, @Query("startTime") DateTime startTime, @Query("endTime") DateTime endTime, @Query("objectiveId") UUID objectiveId, @Query("taskId") UUID taskId);

    }

    /**
     * Get an instance of a specific action plan.
     *
     * @param actionPlanId The action plan to update.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorResponseException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the ActionPlanInstance object if successful.
     */
    public ActionPlanInstance getById(UUID actionPlanId) {
        return getByIdWithServiceResponseAsync(actionPlanId).toBlocking().single().body();
    }

    /**
     * Get an instance of a specific action plan.
     *
     * @param actionPlanId The action plan to update.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<ActionPlanInstance> getByIdAsync(UUID actionPlanId, final ServiceCallback<ActionPlanInstance> serviceCallback) {
        return ServiceFuture.fromResponse(getByIdWithServiceResponseAsync(actionPlanId), serviceCallback);
    }

    /**
     * Get an instance of a specific action plan.
     *
     * @param actionPlanId The action plan to update.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ActionPlanInstance object
     */
    public Observable<ActionPlanInstance> getByIdAsync(UUID actionPlanId) {
        return getByIdWithServiceResponseAsync(actionPlanId).map(new Func1<ServiceResponse<ActionPlanInstance>, ActionPlanInstance>() {
            @Override
            public ActionPlanInstance call(ServiceResponse<ActionPlanInstance> response) {
                return response.body();
            }
        });
    }

    /**
     * Get an instance of a specific action plan.
     *
     * @param actionPlanId The action plan to update.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ActionPlanInstance object
     */
    public Observable<ServiceResponse<ActionPlanInstance>> getByIdWithServiceResponseAsync(UUID actionPlanId) {
        if (actionPlanId == null) {
            throw new IllegalArgumentException("Parameter actionPlanId is required and cannot be null.");
        }
        return service.getById(actionPlanId)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<ActionPlanInstance>>>() {
                @Override
                public Observable<ServiceResponse<ActionPlanInstance>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<ActionPlanInstance> clientResponse = getByIdDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<ActionPlanInstance> getByIdDelegate(Response<ResponseBody> response) throws ErrorResponseException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<ActionPlanInstance, ErrorResponseException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<ActionPlanInstance>() { }.getType())
                .registerError(ErrorResponseException.class)
                .build(response);
    }

    /**
     * Delete an action plan instance.
     *
     * @param actionPlanId The instance of the plan to delete.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorResponseException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void delete(UUID actionPlanId) {
        deleteWithServiceResponseAsync(actionPlanId).toBlocking().single().body();
    }

    /**
     * Delete an action plan instance.
     *
     * @param actionPlanId The instance of the plan to delete.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> deleteAsync(UUID actionPlanId, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(deleteWithServiceResponseAsync(actionPlanId), serviceCallback);
    }

    /**
     * Delete an action plan instance.
     *
     * @param actionPlanId The instance of the plan to delete.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> deleteAsync(UUID actionPlanId) {
        return deleteWithServiceResponseAsync(actionPlanId).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Delete an action plan instance.
     *
     * @param actionPlanId The instance of the plan to delete.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> deleteWithServiceResponseAsync(UUID actionPlanId) {
        if (actionPlanId == null) {
            throw new IllegalArgumentException("Parameter actionPlanId is required and cannot be null.");
        }
        return service.delete(actionPlanId)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = deleteDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> deleteDelegate(Response<ResponseBody> response) throws ErrorResponseException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<Void, ErrorResponseException>newInstance(this.client.serializerAdapter())
                .register(204, new TypeToken<Void>() { }.getType())
                .registerError(ErrorResponseException.class)
                .build(response);
    }

    /**
     * Get a collection of action plans.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorResponseException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the ActionPlansResponseActionPlanInstance object if successful.
     */
    public ActionPlansResponseActionPlanInstance get() {
        return getWithServiceResponseAsync().toBlocking().single().body();
    }

    /**
     * Get a collection of action plans.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<ActionPlansResponseActionPlanInstance> getAsync(final ServiceCallback<ActionPlansResponseActionPlanInstance> serviceCallback) {
        return ServiceFuture.fromResponse(getWithServiceResponseAsync(), serviceCallback);
    }

    /**
     * Get a collection of action plans.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ActionPlansResponseActionPlanInstance object
     */
    public Observable<ActionPlansResponseActionPlanInstance> getAsync() {
        return getWithServiceResponseAsync().map(new Func1<ServiceResponse<ActionPlansResponseActionPlanInstance>, ActionPlansResponseActionPlanInstance>() {
            @Override
            public ActionPlansResponseActionPlanInstance call(ServiceResponse<ActionPlansResponseActionPlanInstance> response) {
                return response.body();
            }
        });
    }

    /**
     * Get a collection of action plans.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ActionPlansResponseActionPlanInstance object
     */
    public Observable<ServiceResponse<ActionPlansResponseActionPlanInstance>> getWithServiceResponseAsync() {
        final Integer maxPageSize = null;
        return service.get(maxPageSize)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<ActionPlansResponseActionPlanInstance>>>() {
                @Override
                public Observable<ServiceResponse<ActionPlansResponseActionPlanInstance>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<ActionPlansResponseActionPlanInstance> clientResponse = getDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Get a collection of action plans.
     *
     * @param maxPageSize The maximum number of entries to return per page. Defaults to 1000.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorResponseException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the ActionPlansResponseActionPlanInstance object if successful.
     */
    public ActionPlansResponseActionPlanInstance get(Integer maxPageSize) {
        return getWithServiceResponseAsync(maxPageSize).toBlocking().single().body();
    }

    /**
     * Get a collection of action plans.
     *
     * @param maxPageSize The maximum number of entries to return per page. Defaults to 1000.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<ActionPlansResponseActionPlanInstance> getAsync(Integer maxPageSize, final ServiceCallback<ActionPlansResponseActionPlanInstance> serviceCallback) {
        return ServiceFuture.fromResponse(getWithServiceResponseAsync(maxPageSize), serviceCallback);
    }

    /**
     * Get a collection of action plans.
     *
     * @param maxPageSize The maximum number of entries to return per page. Defaults to 1000.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ActionPlansResponseActionPlanInstance object
     */
    public Observable<ActionPlansResponseActionPlanInstance> getAsync(Integer maxPageSize) {
        return getWithServiceResponseAsync(maxPageSize).map(new Func1<ServiceResponse<ActionPlansResponseActionPlanInstance>, ActionPlansResponseActionPlanInstance>() {
            @Override
            public ActionPlansResponseActionPlanInstance call(ServiceResponse<ActionPlansResponseActionPlanInstance> response) {
                return response.body();
            }
        });
    }

    /**
     * Get a collection of action plans.
     *
     * @param maxPageSize The maximum number of entries to return per page. Defaults to 1000.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ActionPlansResponseActionPlanInstance object
     */
    public Observable<ServiceResponse<ActionPlansResponseActionPlanInstance>> getWithServiceResponseAsync(Integer maxPageSize) {
        return service.get(maxPageSize)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<ActionPlansResponseActionPlanInstance>>>() {
                @Override
                public Observable<ServiceResponse<ActionPlansResponseActionPlanInstance>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<ActionPlansResponseActionPlanInstance> clientResponse = getDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<ActionPlansResponseActionPlanInstance> getDelegate(Response<ResponseBody> response) throws ErrorResponseException, IOException {
        return this.client.restClient().responseBuilderFactory().<ActionPlansResponseActionPlanInstance, ErrorResponseException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<ActionPlansResponseActionPlanInstance>() { }.getType())
                .registerError(ErrorResponseException.class)
                .build(response);
    }

    /**
     * Update/Replace a complete action plan instance with no merge.
     *
     * @param actionPlan The instance of the plan to update. The entire plan will be replaced with this version.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorResponseException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the ActionPlanInstance object if successful.
     */
    public ActionPlanInstance replace(ActionPlanInstance actionPlan) {
        return replaceWithServiceResponseAsync(actionPlan).toBlocking().single().body();
    }

    /**
     * Update/Replace a complete action plan instance with no merge.
     *
     * @param actionPlan The instance of the plan to update. The entire plan will be replaced with this version.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<ActionPlanInstance> replaceAsync(ActionPlanInstance actionPlan, final ServiceCallback<ActionPlanInstance> serviceCallback) {
        return ServiceFuture.fromResponse(replaceWithServiceResponseAsync(actionPlan), serviceCallback);
    }

    /**
     * Update/Replace a complete action plan instance with no merge.
     *
     * @param actionPlan The instance of the plan to update. The entire plan will be replaced with this version.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ActionPlanInstance object
     */
    public Observable<ActionPlanInstance> replaceAsync(ActionPlanInstance actionPlan) {
        return replaceWithServiceResponseAsync(actionPlan).map(new Func1<ServiceResponse<ActionPlanInstance>, ActionPlanInstance>() {
            @Override
            public ActionPlanInstance call(ServiceResponse<ActionPlanInstance> response) {
                return response.body();
            }
        });
    }

    /**
     * Update/Replace a complete action plan instance with no merge.
     *
     * @param actionPlan The instance of the plan to update. The entire plan will be replaced with this version.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ActionPlanInstance object
     */
    public Observable<ServiceResponse<ActionPlanInstance>> replaceWithServiceResponseAsync(ActionPlanInstance actionPlan) {
        if (actionPlan == null) {
            throw new IllegalArgumentException("Parameter actionPlan is required and cannot be null.");
        }
        Validator.validate(actionPlan);
        return service.replace(actionPlan)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<ActionPlanInstance>>>() {
                @Override
                public Observable<ServiceResponse<ActionPlanInstance>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<ActionPlanInstance> clientResponse = replaceDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<ActionPlanInstance> replaceDelegate(Response<ResponseBody> response) throws ErrorResponseException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<ActionPlanInstance, ErrorResponseException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<ActionPlanInstance>() { }.getType())
                .registerError(ErrorResponseException.class)
                .build(response);
    }

    /**
     * Post an action plan instance.
     *
     * @param actionPlan The instance of the plan to create.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorResponseException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the ActionPlanInstance object if successful.
     */
    public ActionPlanInstance create(ActionPlan actionPlan) {
        return createWithServiceResponseAsync(actionPlan).toBlocking().single().body();
    }

    /**
     * Post an action plan instance.
     *
     * @param actionPlan The instance of the plan to create.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<ActionPlanInstance> createAsync(ActionPlan actionPlan, final ServiceCallback<ActionPlanInstance> serviceCallback) {
        return ServiceFuture.fromResponse(createWithServiceResponseAsync(actionPlan), serviceCallback);
    }

    /**
     * Post an action plan instance.
     *
     * @param actionPlan The instance of the plan to create.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ActionPlanInstance object
     */
    public Observable<ActionPlanInstance> createAsync(ActionPlan actionPlan) {
        return createWithServiceResponseAsync(actionPlan).map(new Func1<ServiceResponse<ActionPlanInstance>, ActionPlanInstance>() {
            @Override
            public ActionPlanInstance call(ServiceResponse<ActionPlanInstance> response) {
                return response.body();
            }
        });
    }

    /**
     * Post an action plan instance.
     *
     * @param actionPlan The instance of the plan to create.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ActionPlanInstance object
     */
    public Observable<ServiceResponse<ActionPlanInstance>> createWithServiceResponseAsync(ActionPlan actionPlan) {
        if (actionPlan == null) {
            throw new IllegalArgumentException("Parameter actionPlan is required and cannot be null.");
        }
        Validator.validate(actionPlan);
        return service.create(actionPlan)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<ActionPlanInstance>>>() {
                @Override
                public Observable<ServiceResponse<ActionPlanInstance>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<ActionPlanInstance> clientResponse = createDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<ActionPlanInstance> createDelegate(Response<ResponseBody> response) throws ErrorResponseException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<ActionPlanInstance, ErrorResponseException>newInstance(this.client.serializerAdapter())
                .register(201, new TypeToken<ActionPlanInstance>() { }.getType())
                .registerError(ErrorResponseException.class)
                .build(response);
    }

    /**
     * Update an action plan instance with merge.
     *
     * @param actionPlan The instance of the plan to update. Only the fields present in the passed in model will be updated. All other fields and colelctions
                 will be left, as is, unless invalid.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorResponseException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the ActionPlanInstance object if successful.
     */
    public ActionPlanInstance update(ActionPlanInstance actionPlan) {
        return updateWithServiceResponseAsync(actionPlan).toBlocking().single().body();
    }

    /**
     * Update an action plan instance with merge.
     *
     * @param actionPlan The instance of the plan to update. Only the fields present in the passed in model will be updated. All other fields and colelctions
                 will be left, as is, unless invalid.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<ActionPlanInstance> updateAsync(ActionPlanInstance actionPlan, final ServiceCallback<ActionPlanInstance> serviceCallback) {
        return ServiceFuture.fromResponse(updateWithServiceResponseAsync(actionPlan), serviceCallback);
    }

    /**
     * Update an action plan instance with merge.
     *
     * @param actionPlan The instance of the plan to update. Only the fields present in the passed in model will be updated. All other fields and colelctions
                 will be left, as is, unless invalid.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ActionPlanInstance object
     */
    public Observable<ActionPlanInstance> updateAsync(ActionPlanInstance actionPlan) {
        return updateWithServiceResponseAsync(actionPlan).map(new Func1<ServiceResponse<ActionPlanInstance>, ActionPlanInstance>() {
            @Override
            public ActionPlanInstance call(ServiceResponse<ActionPlanInstance> response) {
                return response.body();
            }
        });
    }

    /**
     * Update an action plan instance with merge.
     *
     * @param actionPlan The instance of the plan to update. Only the fields present in the passed in model will be updated. All other fields and colelctions
                 will be left, as is, unless invalid.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ActionPlanInstance object
     */
    public Observable<ServiceResponse<ActionPlanInstance>> updateWithServiceResponseAsync(ActionPlanInstance actionPlan) {
        if (actionPlan == null) {
            throw new IllegalArgumentException("Parameter actionPlan is required and cannot be null.");
        }
        Validator.validate(actionPlan);
        return service.update(actionPlan)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<ActionPlanInstance>>>() {
                @Override
                public Observable<ServiceResponse<ActionPlanInstance>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<ActionPlanInstance> clientResponse = updateDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<ActionPlanInstance> updateDelegate(Response<ResponseBody> response) throws ErrorResponseException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<ActionPlanInstance, ErrorResponseException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<ActionPlanInstance>() { }.getType())
                .registerError(ErrorResponseException.class)
                .build(response);
    }

    /**
     * Gets adherence information for an action plan.
     *
     * @param startTime The start time.
     * @param endTime The end time.
     * @param actionPlanId The action plan identifier.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorResponseException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the ActionPlanAdherenceSummary object if successful.
     */
    public ActionPlanAdherenceSummary getAdherence(DateTime startTime, DateTime endTime, UUID actionPlanId) {
        return getAdherenceWithServiceResponseAsync(startTime, endTime, actionPlanId).toBlocking().single().body();
    }

    /**
     * Gets adherence information for an action plan.
     *
     * @param startTime The start time.
     * @param endTime The end time.
     * @param actionPlanId The action plan identifier.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<ActionPlanAdherenceSummary> getAdherenceAsync(DateTime startTime, DateTime endTime, UUID actionPlanId, final ServiceCallback<ActionPlanAdherenceSummary> serviceCallback) {
        return ServiceFuture.fromResponse(getAdherenceWithServiceResponseAsync(startTime, endTime, actionPlanId), serviceCallback);
    }

    /**
     * Gets adherence information for an action plan.
     *
     * @param startTime The start time.
     * @param endTime The end time.
     * @param actionPlanId The action plan identifier.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ActionPlanAdherenceSummary object
     */
    public Observable<ActionPlanAdherenceSummary> getAdherenceAsync(DateTime startTime, DateTime endTime, UUID actionPlanId) {
        return getAdherenceWithServiceResponseAsync(startTime, endTime, actionPlanId).map(new Func1<ServiceResponse<ActionPlanAdherenceSummary>, ActionPlanAdherenceSummary>() {
            @Override
            public ActionPlanAdherenceSummary call(ServiceResponse<ActionPlanAdherenceSummary> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets adherence information for an action plan.
     *
     * @param startTime The start time.
     * @param endTime The end time.
     * @param actionPlanId The action plan identifier.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ActionPlanAdherenceSummary object
     */
    public Observable<ServiceResponse<ActionPlanAdherenceSummary>> getAdherenceWithServiceResponseAsync(DateTime startTime, DateTime endTime, UUID actionPlanId) {
        if (startTime == null) {
            throw new IllegalArgumentException("Parameter startTime is required and cannot be null.");
        }
        if (endTime == null) {
            throw new IllegalArgumentException("Parameter endTime is required and cannot be null.");
        }
        if (actionPlanId == null) {
            throw new IllegalArgumentException("Parameter actionPlanId is required and cannot be null.");
        }
        final UUID objectiveId = null;
        final UUID taskId = null;
        return service.getAdherence(actionPlanId, startTime, endTime, objectiveId, taskId)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<ActionPlanAdherenceSummary>>>() {
                @Override
                public Observable<ServiceResponse<ActionPlanAdherenceSummary>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<ActionPlanAdherenceSummary> clientResponse = getAdherenceDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Gets adherence information for an action plan.
     *
     * @param startTime The start time.
     * @param endTime The end time.
     * @param actionPlanId The action plan identifier.
     * @param objectiveId The objective to filter the report to.
     * @param taskId The task to filter the report to.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorResponseException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the ActionPlanAdherenceSummary object if successful.
     */
    public ActionPlanAdherenceSummary getAdherence(DateTime startTime, DateTime endTime, UUID actionPlanId, UUID objectiveId, UUID taskId) {
        return getAdherenceWithServiceResponseAsync(startTime, endTime, actionPlanId, objectiveId, taskId).toBlocking().single().body();
    }

    /**
     * Gets adherence information for an action plan.
     *
     * @param startTime The start time.
     * @param endTime The end time.
     * @param actionPlanId The action plan identifier.
     * @param objectiveId The objective to filter the report to.
     * @param taskId The task to filter the report to.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<ActionPlanAdherenceSummary> getAdherenceAsync(DateTime startTime, DateTime endTime, UUID actionPlanId, UUID objectiveId, UUID taskId, final ServiceCallback<ActionPlanAdherenceSummary> serviceCallback) {
        return ServiceFuture.fromResponse(getAdherenceWithServiceResponseAsync(startTime, endTime, actionPlanId, objectiveId, taskId), serviceCallback);
    }

    /**
     * Gets adherence information for an action plan.
     *
     * @param startTime The start time.
     * @param endTime The end time.
     * @param actionPlanId The action plan identifier.
     * @param objectiveId The objective to filter the report to.
     * @param taskId The task to filter the report to.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ActionPlanAdherenceSummary object
     */
    public Observable<ActionPlanAdherenceSummary> getAdherenceAsync(DateTime startTime, DateTime endTime, UUID actionPlanId, UUID objectiveId, UUID taskId) {
        return getAdherenceWithServiceResponseAsync(startTime, endTime, actionPlanId, objectiveId, taskId).map(new Func1<ServiceResponse<ActionPlanAdherenceSummary>, ActionPlanAdherenceSummary>() {
            @Override
            public ActionPlanAdherenceSummary call(ServiceResponse<ActionPlanAdherenceSummary> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets adherence information for an action plan.
     *
     * @param startTime The start time.
     * @param endTime The end time.
     * @param actionPlanId The action plan identifier.
     * @param objectiveId The objective to filter the report to.
     * @param taskId The task to filter the report to.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ActionPlanAdherenceSummary object
     */
    public Observable<ServiceResponse<ActionPlanAdherenceSummary>> getAdherenceWithServiceResponseAsync(DateTime startTime, DateTime endTime, UUID actionPlanId, UUID objectiveId, UUID taskId) {
        if (startTime == null) {
            throw new IllegalArgumentException("Parameter startTime is required and cannot be null.");
        }
        if (endTime == null) {
            throw new IllegalArgumentException("Parameter endTime is required and cannot be null.");
        }
        if (actionPlanId == null) {
            throw new IllegalArgumentException("Parameter actionPlanId is required and cannot be null.");
        }
        return service.getAdherence(actionPlanId, startTime, endTime, objectiveId, taskId)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<ActionPlanAdherenceSummary>>>() {
                @Override
                public Observable<ServiceResponse<ActionPlanAdherenceSummary>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<ActionPlanAdherenceSummary> clientResponse = getAdherenceDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<ActionPlanAdherenceSummary> getAdherenceDelegate(Response<ResponseBody> response) throws ErrorResponseException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<ActionPlanAdherenceSummary, ErrorResponseException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<ActionPlanAdherenceSummary>() { }.getType())
                .registerError(ErrorResponseException.class)
                .build(response);
    }

}
